[{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others‚Äô private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement arc.collaborations@ucl.ac.uk. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla‚Äôs code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to rmcmc","title":"Contributing to rmcmc","text":"outlines propose change rmcmc. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to rmcmc","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ‚Äôll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to rmcmc","text":"want make bigger change, ‚Äôs good idea first file issue make sure someone team agrees ‚Äôs needed. ‚Äôve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to rmcmc","text":"Fork package clone onto computer. haven‚Äôt done , recommend using usethis::create_from_github(\"UCL/rmcmc\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn‚Äôt pass cleanly, ‚Äôs good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e.¬†just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to rmcmc","text":"New code follow tidyverse style guide. can use styler package apply styles, please don‚Äôt restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to rmcmc","text":"Please note rmcmc project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 rmcmc authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/adjusting-noise-distribution.html","id":"example-target-distribution","dir":"Articles","previous_headings":"","what":"Example target distribution","title":"Adjusting the noise distribution in the Barker proposal","text":"simple example target distribution, consider DD-dimensional distribution product form (independent dimensions) ‚Äòhyperbolic‚Äô marginals œÄ(x)‚àùexp(‚àí‚àëd=1D(Œ¥2+xd2)12).\\pi(x) \\propto \\exp\\left(-\\sum_{d=1}^D(\\delta^2 + x_d^2)^{\\frac{1}{2}}\\right). gradient corresponding log density function can derived ‚àá(logœÄ)(x)d=‚àíxd/(Œ¥2+xd2)12.\\nabla(\\log \\pi)(x)_d = -x_d / (\\delta^2 + x_d^2)^{\\frac{1}{2}}. can implemented R use Œ¥2=0.1\\delta^2 = 0.1, corresponding Example 4 Vogrinc, Livingstone, Zanella (2023).","code":"delta_sq <- 0.1 target_distribution <- list(   log_density = function(x) -sum(sqrt(delta_sq + x^2)),   gradient_log_density = function(x) -x / sqrt(delta_sq + x^2) )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/adjusting-noise-distribution.html","id":"creating-barker-proposal-with-a-custom-noise-distribution","dir":"Articles","previous_headings":"","what":"Creating Barker proposal with a custom noise distribution","title":"Adjusting the noise distribution in the Barker proposal","text":"barker_proposal() function accepts optional argument sample_auxiliary, can used specify distribution auxiliary noise variables drawn . argument passed function accepting single integer argument, corresponding target distribution dimension, returning vector auxiliary noise variable samples, one per target distribution dimension. default function set stats::rnorm(), thus using independent standard normal variates auxiliary noise variables. create function sample_bimodal instead samples bimodal normal mixture, two equally-weighted normal components means ¬±(1‚àíœÉ2)\\pm (1 - \\sigma^2) common variance œÉ2=0.01\\sigma^2 = 0.01. choice bimodal distribution auxiliary noise variables motivated analysis Vogrinc, Livingstone, Zanella (2023), shows target distributions product form using Barker proposal, asymptotic expect squared jump distance (ESJD) measure chain sampling performance, maximised auxiliary noise distribution chosen Rademacher distribution (distribution half mass atoms -1 +1). Rademacher distribution give practical sampling algorithm, resulting Markov kernel irreducible. practical alternative Vogrinc, Livingstone, Zanella (2023) therefore suggests using normal mixture bimodal distribution, can considered relaxation Rademacher distribution. now create two instances Barker proposal, first using default standard normal distribution auxiliary noise variables, second using bimodal distribution. convenience function bimodal_barker_proposal() also provided package simplify creating proposal bimodal noise distribution , optional sigma argument specifying standard deviation normal components. second line can equivalently written bimodal_noise_proposal <- bimodal_barker_proposal() without need define sample_bimodal function.","code":"sample_bimodal <- function(dimension) {   sigma <- 0.1   (     sample(c(-1, 1), dimension, TRUE) * sqrt(1 - sigma^2) +       stats::rnorm(dimension) * sigma   ) } normal_noise_proposal <- barker_proposal() bimodal_noise_proposal <- barker_proposal(sample_auxiliary = sample_bimodal)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/adjusting-noise-distribution.html","id":"sampling-chains-with-proposals","dir":"Articles","previous_headings":"","what":"Sampling chains with proposals","title":"Adjusting the noise distribution in the Barker proposal","text":"Now target distribution two proposals specified, can sample chains compare performance. specify common settings sample_chain() calls, namely dimension target distribution, initial chain state (shared chains), adapters use warm-iterations (adapt proposal scale achieve target acceptance rate 0.57), number warm-main chain iterations. can now sample chain using bimodal noise proposal variant similarly using default normal noise proposal","code":"set.seed(7861932L) dimension <- 100 initial_state <- rnorm(dimension) adapters <- list(scale_adapter()) n_warm_up_iteration <- 10000 n_main_iteration <- 10000 bimodal_noise_results <- sample_chain(   target_distribution = target_distribution,   proposal = bimodal_noise_proposal,   initial_state = initial_state,   n_warm_up_iteration = n_warm_up_iteration,   n_main_iteration = n_main_iteration,   adapters = adapters ) normal_noise_results <- sample_chain(   target_distribution = target_distribution,   proposal = normal_noise_proposal,   initial_state = initial_state,   n_warm_up_iteration = n_warm_up_iteration,   n_main_iteration = n_main_iteration,   adapters = adapters )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/adjusting-noise-distribution.html","id":"comparing-performance-of-proposals","dir":"Articles","previous_headings":"","what":"Comparing performance of proposals","title":"Adjusting the noise distribution in the Barker proposal","text":"realisation Markov chain X1:NX_{1:N}, ESJD metric used define notion sampling efficiency optimized Vogrinc, Livingstone, Zanella (2023), can estimated ùñ§ùñ≤ùñ©ùñ£ÃÇ(X1:N)=1N‚àí1‚àën=1N‚àí1‚ÄñXn+1‚àíXn‚Äñ2   \\widehat{\\textsf{ESJD}}(X_{1:N}) = \\frac{1}{N - 1} \\sum_{n=1}^{N-1} \\Vert X_{n+1} - X_n \\Vert^2  corresponding R implementation Applying function chain traces generated using Barker proposal bimodal noise, Barker proposal normal noise, cases selecting columns 1:dimension exclude traced log density values, find proposal bimodal noise gives roughly factor two improvement ESJD compared using normal noise, correlating results Vogrinc, Livingstone, Zanella (2023). Using posterior R package, can compare chains perform terms estimated effective sample size (ESS) estimate mean target log density. First considering chain using Barker proposal bimodal noise similarly Barker proposal normal noise find bimodal noise variant appears show significantly improved sampling efficiency.","code":"expected_square_jumping_distance <- function(traces) {   n_iteration <- nrow(traces)   mean(rowSums(traces[2:n_iteration, ] - traces[1:n_iteration - 1, ])^2) } cat(   sprintf(     \"Expected square jumping distance using normal noise is %.2f\",     expected_square_jumping_distance(bimodal_noise_results$traces[, 1:dimension])   ) ) #> Expected square jumping distance using normal noise is 33.75 cat(   sprintf(     \"Expected square jumping distance using bimodal noise is %.2f\",     expected_square_jumping_distance(normal_noise_results$traces[, 1:dimension])   ) ) #> Expected square jumping distance using bimodal noise is 17.42 library(posterior) #> This is posterior version 1.6.1 #>  #> Attaching package: 'posterior' #> The following objects are masked from 'package:stats': #>  #>     mad, sd, var #> The following objects are masked from 'package:base': #>  #>     %in%, match cat(   sprintf(     \"Estimated ESS of mean(target_log_density) using bimodal noise is %.0f\",     ess_mean(       extract_variable(         as_draws_matrix(bimodal_noise_results$traces), \"target_log_density\"       )     )   ) ) #> Estimated ESS of mean(target_log_density) using bimodal noise is 345 cat(   sprintf(     \"Estimated ESS of mean(target_log_density) using normal noise is %.0f\",     ess_mean(       extract_variable(         as_draws_matrix(normal_noise_results$traces), \"target_log_density\"       )     )   ) ) #> Estimated ESS of mean(target_log_density) using normal noise is 274"},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"example-target-distribution","dir":"Articles","previous_headings":"","what":"Example target distribution","title":"Robust gradient-based MCMC with the Barker proposal","text":"simple example target distribution, consider 10-dimensional Gaussian target heterogeneous scales standard deviation first coordinate 0.01 coordinates 1. rmcmc package expects target distribution specified function evaluating logarithm (potentially unnormalized) probability density point, gradient-based methods Barker proposal, additionally requires specification function evaluating gradient log density function. two functions wrapped list names log_density gradient_log_density respectively.","code":"dimension <- 10 scales <- c(0.01, rep(1, dimension - 1)) target_distribution <- list(   log_density = function(x) -sum((x / scales)^2) / 2,   gradient_log_density = function(x) -x / scales^2 )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"creating-proposal-distribution","dir":"Articles","previous_headings":"","what":"Creating proposal distribution","title":"Robust gradient-based MCMC with the Barker proposal","text":"rmcmc provides implementations several different proposal distributions can used within Metropolis‚ÄìHastings based MCMC method: barker_proposal(): robust gradient-based Barker proposal proposed Livingstone Zanella (2022). langevin_proposal(): gradient-based proposal based discretization Langevin dynamics. hamiltonian_proposal(): gradient-based proposal based discretization Hamiltonian dynamics, simulated fixed number integrator steps. single integrator step equivalent langevin_proposal. random_walk_proposal(): Gaussian random-walk proposal. function takes optional arguments can used customize behaviour proposal scalar scale proposal, vector matrix defining proposal shape routines sample auxiliary variables used proposal. create instance Barker proposal, using default values arguments. Rather specifying fixed scale shape tuning parameters, next section illustrate set adaptation parameters warm-stage chains.","code":"proposal <- barker_proposal()"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"setting-up-adaptation-of-tuning-parameters","dir":"Articles","previous_headings":"","what":"Setting up adaptation of tuning parameters","title":"Robust gradient-based MCMC with the Barker proposal","text":"rmcmc support adaptively tuning parameters proposal distribution. mediated ‚Äòadapter‚Äô objects define method update parameters proposal based chain state statistics recorded chain iteration. instantiate list adapters () adapt scalar scale proposal distribution coerce average acceptance probability chain transitions target value, (ii) adapt shape proposal distribution per-coordinate scaling factors based estimates coordinate-wise variances target distribution. set initial scale ùí™(dimension‚àí16)\\mathcal{O}(\\text{dimension}^{-\\frac{1}{6}}) target acceptance probability 0.574 following guidelines Vogrinc, Livingstone, Zanella (2023). equivalent default behaviour specifying initial_scale target_accept_prob arguments, case proposal dimension dependent values following guidelines Vogrinc, Livingstone, Zanella (2023) used. adapters optional kappa argument can used set decay rate exponent adaptation learning rate. set 0.6, following recommendation Livingstone Zanella (2022), cases. adapter updates applied initial set ‚Äòwarm-‚Äô chain iterations, proposal parameters remaining fixed final adapted values subsequent set main chain iterations.","code":"adapters <- list(   scale_adapter(     algorithm = \"stochastic_approximation\",     initial_scale = dimension^(-1 / 6),     target_accept_prob = 0.574,     kappa = 0.6   ),   shape_adapter(type = \"variance\", kappa = 0.6) )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"sampling-a-chain","dir":"Articles","previous_headings":"","what":"Sampling a chain","title":"Robust gradient-based MCMC with the Barker proposal","text":"sample chain first need specify initial chain state. rmcmc package encapsulates chain state list tracks current position chain, also additional quantities auxiliary variables used generate proposed perturbation state, cached values log density gradient computed current position avoid re-computation. [chain_state()] function allows creation list required format, first (required) argument specifying position. Alternatively can directly pass vector specifying just position component state initial_state argument [sample_chain()]. generate initial state position coordinates sampled independent normal distributions standard deviation 10, following example Livingstone Zanella (2022). reproducibility also fix random seed. now everything needed sample Markov chain. use sample_chain function rmcmc. requires us specify target distribution, proposal distribution, initial chain state, number adaptive warm-iterations non-adaptive main chain iterations list adapters use. sample chain 10410^{4} warm-10410^{4} main chain iterations. set trace_warm_up TRUE record statistics adaptive warm-chain iterations. progress package installed progress bar show chain progress sampling. return value sample_chains list containing fields accessing final chain state (can used start sampling new chain), variables traced main chain iterations additional statistics recorded main chain iterations. trace_warm_up argument sample_chains set TRUE , list returned sample_chains also contain entries warm_up_traces warm_up_statistics corresponding respectively variable traces additional statistics recorded warm-iterations. One additional statistics recorded acceptance probability chain iteration name accept_prob. can therefore compute mean acceptance probability main chain iterations follows: close target acceptance rate 0.574 indicating scale adaptation worked expected. can also inspect shape parameter proposal check variance based shape adaptation succeeded. snippet extracts (first dimensions ) adapted shape proposal object compares known true scales (per-coordinate standard deviations) target distribution. adaptation appears successful adapted shape close true target scales.","code":"set.seed(791285301L) initial_state <- chain_state(10 * rnorm(dimension)) n_warm_up_iteration <- 10000 n_main_iteration <- 10000 barker_results <- sample_chain(   target_distribution = target_distribution,   proposal = proposal,   initial_state = initial_state,   n_warm_up_iteration = n_warm_up_iteration,   n_main_iteration = n_main_iteration,   adapters = adapters,   trace_warm_up = TRUE ) mean_accept_prob <- mean(barker_results$statistics[, \"accept_prob\"]) cat(sprintf(\"Average acceptance probability is %.2f\", mean_accept_prob)) #> Average acceptance probability is 0.54 clipped_dimension <- min(5, dimension) final_shape <- proposal$parameters()$shape cat(   sprintf(\"Adapter scale est.: %s\", toString(final_shape[1:clipped_dimension])),   sprintf(\"True target scales: %s\", toString(scales[1:clipped_dimension])),   sep = \"\\n\" ) #> Adapter scale est.: 0.00922080029766185, 0.995077611400515, 0.975164196791254, 0.938742004951002, 0.959131700160353 #> True target scales: 0.01, 1, 1, 1, 1"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"summarizing-results-using-posterior-package","dir":"Articles","previous_headings":"","what":"Summarizing results using posterior package","title":"Robust gradient-based MCMC with the Barker proposal","text":"output sample_chains can also easily used external packages analyzing MCMC outputs. example posterior package provides implementations various inference diagnostic functions manipulating, subsetting summarizing MCMC outputs. traces entry returned (list) output sample_chain matrix row corresponding chain iterations (named) columns traced variables. matrix can directly coerced draws data format posterior package internally uses represent chain outputs, can passed directly summarize_draws function output tibble data frame containing set summary statistics diagnostic measures variable. can also first explicit convert traces matrix posterior draws object using as_draws_matrix function. can passed summary generic function get equivalent output draws object can also manipulated subsetted various functions provided posterior. example extract_variable function can used extract draws specific named variable. output function can passed various diagnostic functions, example compute effective sample size mean target_log_density variable following","code":"library(posterior) #> This is posterior version 1.6.1 #>  #> Attaching package: 'posterior' #> The following objects are masked from 'package:stats': #>  #>     mad, sd, var #> The following objects are masked from 'package:base': #>  #>     %in%, match summarize_draws(barker_results$traces) #> # A tibble: 11 √ó 10 #>    variable           mean   median     sd    mad      q5     q95  rhat ess_bulk #>    <chr>             <dbl>    <dbl>  <dbl>  <dbl>   <dbl>   <dbl> <dbl>    <dbl> #>  1 position1       1.63e-4  3.51e-4 0.0102 0.0104 -0.0166  0.0169 1.00     1197. #>  2 position2      -3.07e-2 -9.21e-3 1.01   0.990  -1.72    1.62   1.00     1405. #>  3 position3       2.22e-2  1.54e-2 1.01   1.01   -1.61    1.64   1.000    1191. #>  4 position4       2.13e-2  1.25e-2 1.02   1.04   -1.68    1.68   1.000    1250. #>  5 position5       1.78e-2  2.02e-2 0.993  1.01   -1.63    1.62   1.00     1370. #>  6 position6      -2.23e-2 -3.13e-2 1.01   0.996  -1.67    1.65   1.00     1157. #>  7 position7       2.99e-2  4.19e-3 1.00   1.01   -1.59    1.69   1.00     1456. #>  8 position8       2.38e-2 -4.45e-3 1.02   1.01   -1.63    1.75   1.00     1503. #>  9 position9      -3.08e-2 -3.23e-2 1.01   1.02   -1.67    1.62   1.00     1478. #> 10 position10      2.73e-2  1.43e-2 1.01   1.02   -1.61    1.67   1.00     1482. #> 11 target_log_de‚Ä¶ -5.11e+0 -4.71e+0 2.34   2.17   -9.43   -2.00   1.00     1188. #> # ‚Ñπ 1 more variable: ess_tail <dbl> draws <- as_draws_matrix(barker_results$traces) summary(draws) #> # A tibble: 11 √ó 10 #>    variable           mean   median     sd    mad      q5     q95  rhat ess_bulk #>    <chr>             <dbl>    <dbl>  <dbl>  <dbl>   <dbl>   <dbl> <dbl>    <dbl> #>  1 position1       1.63e-4  3.51e-4 0.0102 0.0104 -0.0166  0.0169 1.00     1197. #>  2 position2      -3.07e-2 -9.21e-3 1.01   0.990  -1.72    1.62   1.00     1405. #>  3 position3       2.22e-2  1.54e-2 1.01   1.01   -1.61    1.64   1.000    1191. #>  4 position4       2.13e-2  1.25e-2 1.02   1.04   -1.68    1.68   1.000    1250. #>  5 position5       1.78e-2  2.02e-2 0.993  1.01   -1.63    1.62   1.00     1370. #>  6 position6      -2.23e-2 -3.13e-2 1.01   0.996  -1.67    1.65   1.00     1157. #>  7 position7       2.99e-2  4.19e-3 1.00   1.01   -1.59    1.69   1.00     1456. #>  8 position8       2.38e-2 -4.45e-3 1.02   1.01   -1.63    1.75   1.00     1503. #>  9 position9      -3.08e-2 -3.23e-2 1.01   1.02   -1.67    1.62   1.00     1478. #> 10 position10      2.73e-2  1.43e-2 1.01   1.02   -1.61    1.67   1.00     1482. #> 11 target_log_de‚Ä¶ -5.11e+0 -4.71e+0 2.34   2.17   -9.43   -2.00   1.00     1188. #> # ‚Ñπ 1 more variable: ess_tail <dbl> cat(   sprintf(     \"Effective sample size of mean(target_log_density) is %.0f\",     ess_mean(extract_variable(draws, \"target_log_density\"))   ) ) #> Effective sample size of mean(target_log_density) is 1206"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"sampling-using-a-langevin-proposal","dir":"Articles","previous_headings":"","what":"Sampling using a Langevin proposal","title":"Robust gradient-based MCMC with the Barker proposal","text":"sample chain using Langevin proposal, can simply use langevin_proposal place baker_proposal. create new set adapters using default target_accept_prob argument scale_adapter set target acceptance rate Langevin proposal optimal value 0.574 following results Roberts Rosenthal (2001). can check average acceptance rate main chain iterations close specified target value: use ess_mean function posterior package compute effective sample size mean target_log_density variable","code":"mala_results <- sample_chain(   target_distribution = target_distribution,   proposal = langevin_proposal(),   initial_state = initial_state,   n_warm_up_iteration = n_warm_up_iteration,   n_main_iteration = n_main_iteration,   adapters = list(     scale_adapter(algorithm = \"stochastic_approximation\", kappa = 0.6),     shape_adapter(type = \"variance\", kappa = 0.6)   ),   trace_warm_up = TRUE ) cat(   sprintf(     \"Average acceptance probability is %.2f\",     mean(mala_results$statistics[, \"accept_prob\"])   ) ) #> Average acceptance probability is 0.61 cat(   sprintf(     \"Effective sample size of mean(target_log_density) is %.0f\",     ess_mean(       extract_variable(         as_draws_matrix(mala_results$traces), \"target_log_density\"       )     )   ) ) #> Effective sample size of mean(target_log_density) is 2863"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/barker-proposal.html","id":"comparing-adaptation-using-barker-and-langevin-proposal","dir":"Articles","previous_headings":"","what":"Comparing adaptation using Barker and Langevin proposal","title":"Robust gradient-based MCMC with the Barker proposal","text":"can plot proposal shape scale parameters varied adaptive warm-iterations, accessing statistics recorded warm_up_statistics entry list returned sample_chain. First considering scalar scale parameter œÉt\\sigma_t, controlled achieve target average acceptance rate, see Barker proposal adaptation successfully coerces average acceptance rate close 0.574 target value scale parameter adaptation largely stabilized within first 1000 iterations.  Langevin proposal hand, acceptance rate eventually converge target value 0.574, convergence slower evidence unstable oscillatory behaviour adapted scale.  Now consider adaptation diagonal shape matrix Œ£t\\Sigma_t, based estimates per-coordinate variances. see Barker proposal adaptation quickly converges towards known heterogeneous scales along different coordinates.  Langevin proposal, shape adaptation slower.  can also visualize chain position components warm-iterations using warm_up_traces entry. Barker proposal can see chain quickly appears converge stationary regime  Langevin proposal also appear converge stationary regime convergence slower  Overall see Langevin proposal able achieve higher sampling efficiency tuned appropriate parameters, performance sensitive tuning parameter values resulting less stable robust adaptive tuning.","code":"visualize_scale_adaptation <- function(warm_up_statistics, label) {   n_warm_up_iteration <- nrow(warm_up_statistics)   old_par <- par(mfrow = c(1, 2))   on.exit(par(old_par))   plot(     exp(warm_up_statistics[, \"log_scale\"]),     type = \"l\",     xlab = expression(paste(\"Chain iteration \", t)),     ylab = expression(paste(\"Scale \", sigma[t]))   )   plot(     cumsum(warm_up_statistics[, \"accept_prob\"]) / 1:n_warm_up_iteration,     type = \"l\",     xlab = expression(paste(\"Chain iteration \", t)),     ylab = expression(paste(\"Average acceptance rate \", alpha[t])),     ylim = c(0, 1)   )   mtext(     sprintf(\"Scale adaptation for %s\", label),     side = 3, line = -2, outer = TRUE   ) } visualize_scale_adaptation(barker_results$warm_up_statistics, \"Barker proposal\") visualize_scale_adaptation(mala_results$warm_up_statistics, \"Langevin proposal\") visualize_shape_adaptation <- function(warm_up_statistics, dimensions, label) {   matplot(     sqrt(warm_up_statistics[, paste0(\"variance_estimate\", dimensions)]),     type = \"l\",     xlab = expression(paste(\"Chain iteration \", t)),     ylab = expression(paste(\"Shape \", diag(Sigma[t]^(1 / 2)))),     log = \"y\"   )   legend(     \"right\",     paste0(\"coordinate \", dimensions),     lty = dimensions,     col = dimensions,     bty = \"n\"   )   mtext(     sprintf(\"Shape adaptation for %s\", label),     side = 3, line = -2, outer = TRUE   ) } visualize_shape_adaptation(   barker_results$warm_up_statistics, 1:clipped_dimension, \"Barker proposal\" ) visualize_shape_adaptation(   mala_results$warm_up_statistics, 1:clipped_dimension, \"Langevin proposal\" ) visualize_traces <- function(traces, dimensions, label) {   matplot(     traces[, paste0(\"position\", dimensions)],     type = \"l\",     xlab = expression(paste(\"Chain iteration \", t)),     ylab = expression(paste(\"Position \", X[t])),   )   legend(     \"topright\",     paste0(\"coordinate \", dimensions),     lty = dimensions,     col = dimensions,     bty = \"n\"   )   mtext(sprintf(\"Traces for %s\", label), side = 3, line = -2, outer = TRUE) } visualize_traces(   barker_results$warm_up_traces, 1:clipped_dimension, \"Barker proposal\" ) visualize_traces(   mala_results$warm_up_traces, 1:clipped_dimension, \"Langevin proposal\" )"},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"hodgkin-huxley-model-for-action-potential-generation","dir":"Articles","previous_headings":"","what":"Hodgkin-Huxley model for action potential generation","title":"Interfacing with Stan models via BridgeStan","text":"use example mathematical model describing action potentials neurons generated might fit model data. model interest described Hodgkin Huxley (1952) based experimental investigations squid giant axons. received Nobel Prize Physiology Medicine work 1963. fit model digitisation data original experiments Daly et al. (2015). cell membrane voltage VmV_m modelled controlled voltage-gated ion channels, governing ordinary differential equation (ODE) CmdVmdt=gK(EK‚àíVm)+gNa(ENa‚àíVm)+gL(El‚àíVm)‚àí.  C_m \\frac{\\mathrm{d}V_m}{\\mathrm{d}t} = g_K (E_K - V_m) + g_{Na}(E_{Na} - V_m) + g_L(E_l - V_m) - . CmC_m membrane capacitance per unit area, gKg_K potassium channel conductance, EkE_k potassium channel reversal potential, gNag_{Na} sodium channel conductance, ENaE_{Na} sodium channel reversal potential, gLg_L leakage conductance, ELE_L leakage reversal potential, II membrane current per unit area. Importantly potassium sodium channel conductances, gKg_K gNag_{Na}, time voltage dependent variables. Hodgkin Huxley‚Äôs experiments used ingenious experimental protocol allow measuring evolution cell membrane‚Äôs conductance time specific ion channels clamped specific depolarization voltage. varying extracellular ion concentrations, able isolate effects potassium sodium channels. concentrate model data specifically gKg_{K}, potassium channel conductance. potassium channel conductance modelled gK(t,v,Œ∏)=g‚ÄæKn(t,v,Œ∏)4,g_{\\textrm{K}}(t, v, \\theta) = \\bar{g}_{\\textrm{K}} n(t, v, \\theta)^4, g‚ÄæK\\bar{g}_K maximum potassium channel conductance, nn time voltage dependent subunit activation probability [0,1][0, 1], v=Vrest‚àíVmv = V_{\\text{rest}} - V_m depolarization resting potential VrestV_{\\text{rest}} mV Œ∏=(g‚ÄæK,kŒ±,1,kŒ±,2,kŒ±,3,kŒ≤,1,kŒ≤,2)\\theta = (\\bar{g}_K, k_{\\alpha,1}, k_{\\alpha, 2}, k_{\\alpha, 3}, k_{\\beta, 1}, k_{\\beta,2}) set model parameters. potassium channel subunit activation nn governed linear ODE dn(t,v,Œ∏)dt=n‚àû(v,Œ∏)‚àín(t,v,Œ∏)œÑ(v,Œ∏)\\frac{\\mathrm{d} n(t, v, \\theta)}{\\mathrm{d} t} = \\frac{n_\\infty(v, \\theta) - n(t, v, \\theta)}{\\tau(v, \\theta)} analytic solution n(t,v,Œ∏)=n(0,v,Œ∏)+(n‚àû(v,Œ∏)‚àín(0,v,Œ∏))(1‚àíexp(‚àít/œÑ(v,Œ∏))).   n(t, v, \\theta) = n(0, v, \\theta) + \\left(n_\\infty(v, \\theta) - n(0, v, \\theta)\\right) \\left(1 - \\exp(-t / \\tau(v, \\theta)) \\right). time constant œÑ\\tau equilibrium value n‚àûn_\\infty defined respectively terms rate constant functions Œ±\\alpha Œ≤\\beta œÑ(v,Œ∏)=1Œ±(v,Œ∏)+Œ≤(v,Œ∏),n‚àû(v,Œ∏)=Œ±(v,Œ∏)Œ±(v,Œ∏)+Œ≤(v,Œ∏).   \\tau(v, \\theta) = \\frac{1}{\\alpha(v, \\theta) + \\beta(v, \\theta)},\\quad   n_\\infty(v, \\theta) = \\frac{\\alpha(v, \\theta)}{\\alpha(v, \\theta) + \\beta(v, \\theta)}. rate constants Œ±\\alpha Œ≤\\beta defined respectively terms model parameters Œ±(v,ùõâ)=kŒ±,1(v+kŒ±,2)exp((v+kŒ±,2)/kŒ±,3)‚àí1,Œ≤(v,ùõâ)=kŒ≤,1exp(v/kŒ≤,2).   \\alpha(v, \\boldsymbol{\\theta}) =  \\frac{k_{\\alpha, 1}(v + k_{\\alpha, 2})}{\\exp((v + k_{\\alpha, 2}) / k_{\\alpha, 3}) - 1},   \\quad   \\beta(v, \\boldsymbol{\\theta}) = k_{\\beta, 1} \\exp(v / k_{\\beta, 2}). Together equations define mathematical model potassium conductance gKg_K varies function applied depolarization time, six unknown model parameters Œ∏=(kŒ±,1,kŒ±,2,kŒ±,3,kŒ≤,1,kŒ≤,2,g‚ÄæK)\\theta = (k_{\\alpha,1}, k_{\\alpha,2}, k_{\\alpha,3}, k_{\\beta,1}, k_{\\beta,2}, \\bar{g}_K) need inferred experimental data. Hodgkin Huxley‚Äôs experiments, potassium conductances measured regular time intervals series applied depolarizations. assume recorded conductances subject independent zero-mean Gaussian noise unknown standard deviation œÉ\\sigma, yn‚àºùñ≠ùóàùóãùóÜùñ∫ùóÖ(gK(tn,vn,Œ∏),œÉ)‚àÄn‚àà1:N,   y_{n} \\sim \\mathsf{Normal}(g_K(t_n, v_n, \\theta), \\sigma) \\quad \\forall n \\1{:}N, tnt_n vnv_n pairs measurement times applied depolarization voltages measured potassium conductance yny_n. Altogether seven parameters (kŒ±,1,kŒ±,2,kŒ±,3,kŒ≤,1,kŒ≤,2,g‚ÄæK,œÉ)(k_{\\alpha,1}, k_{\\alpha,2}, k_{\\alpha,3}, k_{\\beta,1}, k_{\\beta,2}, \\bar{g}_K, \\sigma) infer. parameters constrained non-negative. assume apriori independent weakly-informative log normal prior distributions correspond beliefs typical plausible magnitudes parameters: kŒ±,1‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(‚àí3,1),kŒ±,2‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(2,1),kŒ±,3‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(2,1),kŒ≤,1‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(‚àí3,1),kŒ≤,2‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(2,1),g‚ÄæK‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(2,1),œÉ‚àºùñ´ùóàùóÄùñ≠ùóàùóãùóÜùñ∫ùóÖ(0,1). \\begin{aligned}   k_{\\alpha,1} &\\sim \\mathsf{LogNormal}(-3, 1),\\\\   k_{\\alpha,2} &\\sim \\mathsf{LogNormal}(2, 1),\\\\   k_{\\alpha,3} &\\sim \\mathsf{LogNormal}(2, 1),\\\\   k_{\\beta,1} &\\sim \\mathsf{LogNormal}(-3, 1),\\\\   k_{\\beta,2} &\\sim \\mathsf{LogNormal}(2, 1),\\\\   \\bar{g}_K &\\sim \\mathsf{LogNormal}(2, 1),\\\\   \\sigma &\\sim \\mathsf{LogNormal}(0, 1). \\end{aligned}","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"stan-implementation","dir":"Articles","previous_headings":"","what":"Stan implementation","title":"Interfacing with Stan models via BridgeStan","text":"Stan‚Äôs high-level modelling syntax makes easy translate mathematical model efficient numerical implementation. Importantly purposes, due Stan‚Äôs support algorithmic differentiation, able automatically compute derivatives resulting model functions. first declare series user-defined functions functions block Stan model file, corresponding various functions defined symbolically previous section. data block declare names, types dimensions data values read passed data file. data consists three one-dimensional arrays (vectors) length N=136N = 136, corresponding measurement times (times, unit ms), depolarizations applied axons (depolarizations, unit mV) measured conductances (conductances, unit mS cm^{-1}). parameter block declare name, types, dimensions constraints model parameters inferring. rate constant parameters kŒ±k_{\\alpha} kŒ≤k_{\\beta} declared vectors dimension 3 2 respectively. parameters non-negative lower=0 constraint added indicate Stan transform constrained parameters unconstrained representation suitable sampling. now ready put everything together model block. first define log-normal prior distributions model parameters. call earlier defined potassium_conductance function compute simulated potassium conductance values given measurement times depolarizations data parameter values. Finally specify observed conductance values subject independent normal observation noise.","code":"functions {   vector alpha_k(vector v, vector k_alpha) {     return k_alpha[1] .* (v + k_alpha[2])            ./ (exp((v + k_alpha[2]) ./ k_alpha[3]) - 1);   }   vector beta_k(vector v, vector k_beta) {     return k_beta[1] .* exp(v ./ k_beta[2]);   }   vector n_infty(vector v, vector k_alpha, vector k_beta) {     return alpha_k(v, k_alpha) ./ (alpha_k(v, k_alpha) + beta_k(v, k_beta));   }   vector tau_n(vector v, vector k_alpha, vector k_beta) {     return 1 ./ (alpha_k(v, k_alpha) + beta_k(v, k_beta));   }   vector potassium_channel_subunit_activation(     vector t, vector v, vector k_alpha, vector k_beta   ) {     real n_0 = n_infty([0.0]', k_alpha, k_beta)[1]; // Assume starting from equilibrium     return n_0            + (n_infty(v, k_alpha, k_beta) - n_0)              .* (1 - exp(-t ./ tau_n(v, k_alpha, k_beta)));   }   vector potassium_conductance(     vector t, vector v, real g_bar_k, vector k_alpha, vector k_beta, int N   ) {     vector[N] n = potassium_channel_subunit_activation(t, v, k_alpha, k_beta);     return g_bar_k .* n .^ 4;   } } data {   int<lower=1> N;   vector[N] times;   vector[N] depolarizations;   vector[N] conductances; } parameters {   vector<lower=0>[3] k_alpha;   vector<lower=0>[2] k_beta;   real<lower=0> g_bar_k;   real<lower=0> sigma; } model {   //priors   k_alpha[1] ~ lognormal(-3, 1);   k_alpha[2] ~ lognormal(2, 1);   k_alpha[3] ~ lognormal(2, 1);   k_beta[1] ~ lognormal(-3, 1);   k_beta[2] ~ lognormal(2, 1);   g_bar_k ~ lognormal(2, 1);   sigma ~ lognormal(0, 1);   // Solve model to simulate conductances   vector[N] simulated_conductances = potassium_conductance(     times, depolarizations, g_bar_k, k_alpha, k_beta, N   );   // likelihood   conductances ~ normal(simulated_conductances, sigma); }"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Interfacing with Stan models via BridgeStan","text":"data use fit model digitisation experimental data Hodgkin Huxley (1952) due Daly et al. (2015). data written JSON format file hodgkin-huxley-potassium-data.json, contents Using rjson ggplot2 package can visualize conductance data. first read data JSON file data frame. plot conductances measurement times, grouping depolarization level different colour level.","code":"{   \"N\": 136,   \"times\": [         0.151969,  0.346818,  0.540928,  0.708482,  1.08186 ,  1.48128 ,         1.94706 ,  2.77638 ,  4.08767 ,  6.38795 ,  8.74094 ,  0.143946,         0.351982,  0.546323,  0.727155,  1.08817 ,  1.50074 ,  1.96633 ,         2.78252 ,  4.14563 ,  6.41981 ,  8.79894 ,  0.166009,  0.360627,         0.564685,  0.719812,  1.10767 ,  1.51457 ,  1.98016 ,  2.79612 ,         4.14918 ,  6.43957 ,  8.78951 , 11.2179  ,  0.181155,  0.38587 ,         0.570391,  0.745402,  1.12413 ,  1.51208 ,  1.9878  ,  2.81355 ,         4.15654 ,  6.40831 ,  8.79632 , 11.2246  ,  0.176417,  0.390884,         0.575647,  0.750935,  1.12043 ,  1.52861 ,  1.99489 ,  2.8308  ,         4.17366 ,  6.44379 ,  8.80331 , 11.2411  ,  0.189592,  0.384833,         0.569941,  0.754981,  1.1346  ,  1.54314 ,  1.99071 ,  2.81711 ,         4.16031 ,  6.42045 ,  8.79916 , 11.2174  , 11.9878  ,  0.192635,         0.387599,  0.582563,  0.758058,  1.11856 ,  1.53733 ,  2.00485 ,         2.8225  ,  4.15637 ,  6.4459  ,  8.81437 , 11.2423  , 12.0029  ,         0.185443,  0.351221,  0.565688,  0.750969,  1.16043 ,  1.56976 ,         1.99835 ,  2.84581 ,  4.18023 ,  6.45033 ,  8.82848 , 11.2172  ,        11.9973  ,  0.187172,  0.362701,  0.567555,  0.77234 ,  1.12336 ,         1.5522  ,  2.01038 ,  2.81901 ,  4.17345 ,  6.46347 ,  8.83215 ,        11.2404  , 12.0104  ,  0.189039,  0.345169,  0.579174,  0.774242,         1.12527 ,  1.58342 ,  2.02211 ,  2.84087 ,  4.18601 ,  6.43774 ,         8.83581 , 11.2438  , 12.0042  ,  0.174412,  0.320652,  0.583981,         0.749621,  1.12018 ,  1.51018 ,  2.00731 ,  2.84564 ,  4.19074 ,         6.41301 ,  8.83059 , 11.2483  , 11.9989   ],   \"depolarizations\": [        -109.0  , -109.0 , -109.0 , -109.0 , -109.0  , -109.0  , -109.0  ,        -109.0  , -109.0  , -109.0  , -109.0  , -100.0  , -100.0  , -100.0  ,        -100.0  , -100.0  , -100.0  , -100.0  , -100.0  , -100.0  , -100.0  ,        -100.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,         -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -88.0  ,  -76.0  ,         -76.0  ,  -76.0  ,  -76.0  ,  -76.0  ,  -76.0  ,  -76.0  ,  -76.0  ,         -76.0  ,  -76.0  ,  -76.0  ,  -76.0  ,  -63.0  ,  -63.0  ,  -63.0  ,         -63.0  ,  -63.0  ,  -63.0  ,  -63.0  ,  -63.0  ,  -63.0  ,  -63.0  ,         -63.0  ,  -63.0  ,  -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,         -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,  -51.0  ,         -51.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,         -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,  -38.0  ,         -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,         -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -32.0  ,  -26.0  ,         -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,         -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,  -26.0  ,  -19.0  ,  -19.0  ,         -19.0  ,  -19.0  ,  -19.0  ,  -19.0  ,  -19.0  ,  -19.0  ,  -19.0  ,         -19.0  ,  -19.0  ,  -19.0  ,  -19.0  ,  -10.01,  -10.01,  -10.01,         -10.01,  -10.01,  -10.01,  -10.01,  -10.01,  -10.01,  -10.01,         -10.01,  -10.01,  -10.01   ],   \"conductances\": [         0.26035 ,  0.469177,  1.50235 ,  3.15343 ,  7.28047 , 11.3564  ,        13.939   , 17.0936  , 19.2759  , 20.5448  , 21.0415  ,  0.7394  ,         0.742386,  1.5346  ,  2.90553 ,  6.38418 , 10.3899  , 13.2385  ,        16.6184  , 19.0589  , 20.4598  , 20.8098  ,  0.25768 ,  0.719578,         1.526   ,  2.52307 ,  4.97748 ,  7.9296  , 10.6912  , 14.223   ,        16.9205  , 18.3299  , 18.5922  , 18.3581  ,  0.196537,  0.276938,         1.13222 ,  1.71605 ,  3.50426 ,  5.87397 ,  8.24492 , 11.7835  ,        14.8643  , 15.865   , 17.1777  , 17.0957  ,  0.514338,  0.596152,         1.18937 ,  1.46748 ,  2.6933  ,  4.27401 ,  6.32801 ,  9.45034 ,        12.7374  , 15.0535  , 15.5203  , 15.6734  ,  0.72418 ,  0.499035,         0.691458,  0.959828,  1.72454 ,  2.86938 ,  3.97679 ,  6.72229 ,         9.5129  , 12.0124  , 12.8047  , 13.0659  , 13.0006  ,  0.342299,         0.420447,  0.498595,  0.538739,  0.883313,  1.49284 ,  2.10304 ,         3.73692 ,  6.05714 ,  8.39047 ,  9.70601 , 10.0035  , 10.0517  ,         0.394772,  0.397135,  0.478621,  0.481263,  0.604742,  0.885073,         1.44017 ,  2.51102 ,  4.29465 ,  6.64062 ,  8.08621 ,  8.59084 ,         8.68039 ,  0.482695,  0.485248,  0.408227,  0.411206,  0.456312,         0.742553,  0.90922 ,  1.80099 ,  3.02071 ,  4.93404 ,  6.08851 ,         6.64355 ,  7.05475 ,  0.410034,  0.301024,  0.341214,  0.306803,         0.348568,  0.539926,  0.693985,  1.11242 ,  1.76018 ,  2.75348 ,         3.67468 ,  4.37379 ,  4.71736 ,  0.243338,  0.253563,  0.244784,         0.284204,  0.285513,  0.306307,  0.366316,  0.456655,  0.636163,         0.954693,  1.19624 ,  1.38924 ,  1.47927   ] } library(rjson) library(ggplot2) data <- data.frame(fromJSON(file = \"hodgkin-huxley-potassium-data.json\")) ggplot(   data = data, aes(x = times, y = conductances, colour = factor(depolarizations)) ) +   geom_line() +   geom_point() +   labs(     x = \"Times / ms\", y = \"Conductances / mS cm-2\", colour = \"Depolarizations / mV\"   )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"fitting-model-with-rmcmc","dir":"Articles","previous_headings":"","what":"Fitting model with rmcmc","title":"Interfacing with Stan models via BridgeStan","text":"now ready sample model‚Äôs posterior distribution using rmcmc. use BridgeStan construct StanModel object files defining Stan model data. creating model object, set fixed random seed use seed global R random number generator state. also use seed (separate) random number generator state used BridgeStan. now create model object, passing paths Stan model file JSON data file respectively, well integer seed internal Stan random number generator state. rmcmc requires initial chain state explicitly specified. StanModel object just created includes method param_unc_num can used evaluate dimension unconstrained model parameter space perform inference . use arbitrary choice initializing random uniform values (0, 1) unconstrained space. now components need sample chain using rmcmc. sample_chain() function main entry point rmcmc. takes several arguments, one important target_distribution specifying distribution generate approximate samples . can supplied various formats; exploit ability pass BridgeStan StanModel instance directly, internally mapped target_distribution_from_stan_model() function. function can called explicitly additional control, example customizing whether values defined Stan generated quantities transformed parameters blocks included traced chain outputs. also pass sampled initial state specify use 100000 iterations initial adaptive warm-main (non-adaptive) sampling stages. chain length takes around minute sample laptop. Finally explicitly specify adaptation scheme used learn proposal scale shape parameters. overrides default choice using dense shape matrix based estimated covariances, instead use diagonal shape matrix based just estimated variances. found give robuster sampling practice .","code":"library(bridgestan) seed <- 7861223L set.seed(seed) model <- StanModel$new(   \"hodgkin-huxley-potassium-model.stan\",   \"hodgkin-huxley-potassium-data.json\",   seed ) initial_state <- runif(model$param_unc_num()) results <- sample_chain(   target_distribution = model,   initial_state = initial_state,   n_warm_up_iteration = 100000,   n_main_iteration = 100000,   adapters = list(scale_adapter(), shape_adapter(\"variance\")) )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"checking-results-with-posterior","dir":"Articles","previous_headings":"","what":"Checking results with posterior","title":"Interfacing with Stan models via BridgeStan","text":"can use posterior package compute summary statistics convergence diagnostics sampled chain. results$traces matrix (rows corresponding chain iterations column traced variables) can passed directly main functions posterior package, explicitly create draws object allow using functions subsetting draws. first compute display series convergence diagnostics, using subset_draws function posterior filter traced variables corresponding model parameters (accessed using model$param_names() method): rank-normalized RÃÇ\\hat{R} values close 1 indicative chain converged, though note sampled single chain power diagnostic limited. effective sample size (ESS) estimates bulk tail low side, suggest able compute reasonably informative posterior estimates. can also compute summary statistics posterior distribution model parameters:","code":"library(posterior) #> This is posterior version 1.6.1 #>  #> Attaching package: 'posterior' #> The following objects are masked from 'package:stats': #>  #>     mad, sd, var #> The following objects are masked from 'package:base': #>  #>     %in%, match draws <- as_draws(results$traces) summarize_draws(   subset_draws(draws, model$param_names()), default_convergence_measures() ) #> # A tibble: 7 √ó 4 #>   variable   rhat ess_bulk ess_tail #>   <chr>     <dbl>    <dbl>    <dbl> #> 1 k_alpha.1  1.01    187.     498.  #> 2 k_alpha.2  1.01     52.7     88.7 #> 3 k_alpha.3  1.01    164.     386.  #> 4 k_beta.1   1.00    163.     255.  #> 5 k_beta.2   1.01     34.6     81.4 #> 6 g_bar_k    1.02     40.6     87.5 #> 7 sigma      1.01    231.     583. summarize_draws(subset_draws(draws, model$param_names()), default_summary_measures()) #> # A tibble: 7 √ó 7 #>   variable       mean    median         sd        mad        q5       q95 #>   <chr>         <dbl>     <dbl>      <dbl>      <dbl>     <dbl>     <dbl> #> 1 k_alpha.1   0.00928   0.00927   0.000184   0.000189   0.00898   0.00958 #> 2 k_alpha.2   0.756     0.687     0.379      0.344      0.268     1.45    #> 3 k_alpha.3   3.51      3.51      0.297      0.296      3.04      4.02    #> 4 k_beta.1    0.107     0.107     0.00319    0.00308    0.102     0.112   #> 5 k_beta.2  362.      334.      138.       101.       208.      618.      #> 6 g_bar_k    27.5      27.5       0.858      0.831     26.1      28.9     #> 7 sigma       0.350     0.348     0.0228     0.0225     0.316     0.390"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/articles/interfacing-with-stan-models.html","id":"visualising-posterior-with-bayesplot","dir":"Articles","previous_headings":"","what":"Visualising posterior with bayesplot","title":"Interfacing with Stan models via BridgeStan","text":"well able compute diagnostics statistics using posterior package, sampled chain can also visualized using bayesplot package. example, can plot pair plot univariate bivariate marginal posterior distributions parameters follows:  use thin_draws function posterior package thin draws factor 10 reduce number points needing binned plots. reduces time required produce plot minimal effect variances plotted densities.","code":"library(bayesplot) #> This is bayesplot version 1.13.0 #> - Online documentation and vignettes at mc-stan.org/bayesplot #> - bayesplot theme set to bayesplot::theme_default() #>    * Does _not_ affect other ggplot2 plots #>    * See ?bayesplot_theme_set for details on theme setting #>  #> Attaching package: 'bayesplot' #> The following object is masked from 'package:posterior': #>  #>     rhat mcmc_pairs(   thin_draws(subset_draws(draws, model$param_names()), 10),   diag_fun = \"dens\",   off_diag_fun = \"hex\" ) #> Warning: Only one chain in 'x'. This plot is more useful with multiple chains."},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew M. Graham. Author, maintainer. Samuel Livingstone. Author. University College London. Copyright holder. Engineering Physical Sciences Research Council. Funder.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Graham MM, Livingstone S (2025). rmcmc: Robust Markov Chain Monte Carlo Methods. R package version 0.1.1.9000, https://github.com/UCL/rmcmc.","code":"@Manual{,   title = {rmcmc: Robust Markov Chain Monte Carlo Methods},   author = {Matthew M. Graham and Samuel Livingstone},   year = {2025},   note = {R package version 0.1.1.9000},   url = {https://github.com/UCL/rmcmc}, }"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/index.html","id":"rmcmc-robust-markov-chain-monte-carlo-methods","dir":"","previous_headings":"","what":"Robust Markov Chain Monte Carlo Methods","title":"Robust Markov Chain Monte Carlo Methods","text":"rmcmc R package simulating Markov chains using Barker proposal compute Markov chain Monte Carlo (MCMC) estimates expectations respect target distribution real-valued vector space. Barker proposal, described Livingstone Zanella (2022), gradient-based MCMC algorithm inspired Barker accept-reject rule. combines robustness simpler MCMC schemes, random-walk Metropolis, efficiency gradient-based methods, Metropolis adjusted Langevin algorithm. key function provided package sample_chain(), allows sampling Markov chain specified target distribution stationary distribution. chain sampled generating proposals accepting rejecting using Metropolis-Hasting acceptance rule. initial warm-stage, parameters proposal distribution can adapted, adapters available : tune scale proposals coercing average acceptance rate target value; tune shape proposals match covariance estimates target distribution. well default Barker proposal, package also provides implementations alternative proposal distributions, (Gaussian) random walk Langevin proposals. Optionally, BridgeStan‚Äôs R interface, available GitHub, installed, BridgeStan can used specify target distribution sample .","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Robust Markov Chain Monte Carlo Methods","text":"latest published release version rmcmc CRAN can installed using Alternatively, current development version rmcmc can installed using","code":"install.packages(\"rmcmc\") # install.packages(\"devtools\") devtools::install_github(\"UCL/rmcmc\")"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Robust Markov Chain Monte Carlo Methods","text":"snippet shows basic example using package generate samples normal target distribution random scales. Adapters used tune proposal scale achieve target average acceptance probability, tune proposal shape per-dimension scale factors based online estimates target distribution variances. second example, snippet demonstrates sampling two-dimensional banana shaped distribution based Rosenbrock function plotting generated chain samples. use default values proposal adapters arguments sample_chain(), corresponding respectively Barker proposal, adapters tuning proposal scale coerce average acceptance rate using dual-averaging algorithm, tuning proposal shape based estimate target distribution covariance matrix. target_distribution argument sample_chain() passed formula specifying log density target distribution, passed target_distribution_from_log_density_formula() construct necessary functions, using stats::deriv() symbolically compute derivatives.","code":"library(rmcmc)  set.seed(876287L) dimension <- 3 scales <- exp(rnorm(dimension)) target_distribution <- list(   log_density = function(x) -sum((x / scales)^2) / 2,   gradient_log_density = function(x) -x / scales^2 ) proposal <- barker_proposal() results <- sample_chain(   target_distribution = target_distribution,   initial_state = rnorm(dimension),   n_warm_up_iteration = 10000,   n_main_iteration = 10000,   proposal = proposal,   adapters = list(scale_adapter(), shape_adapter(\"variance\")) ) mean_accept_prob <- mean(results$statistics[, \"accept_prob\"]) adapted_shape <- proposal$parameters()$shape cat(   sprintf(\"Average acceptance probability is %.2f\", mean_accept_prob),   sprintf(\"True target scales: %s\", toString(scales)),   sprintf(\"Adapter scale est.: %s\", toString(adapted_shape)),   sep = \"\\n\" ) #> Average acceptance probability is 0.58 #> True target scales: 1.50538046096953, 1.37774732725824, 0.277038897322645 #> Adapter scale est.: 1.5328097767097, 1.42342707172926, 0.280359693392091 library(rmcmc)  set.seed(651239L) results <- sample_chain(   target_distribution = ~ (-(x^2 + y^2) / 8 - (x^2 - y)^2 - (x - 1)^2 / 100),   initial_state = rnorm(2),   n_warm_up_iteration = 10000,   n_main_iteration = 10000 ) plot(results$traces[, \"x\"], results$traces[, \"y\"], col = \"#1f77b4\", pch = 20)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new Barker proposal object. ‚Äî barker_proposal","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"Barker proposal gradient-based proposal inspired Barker accept-reject rule proposed Livingstone Zanella (2022). offers improved robustness compared alternative gradient-based proposals Langevin proposals.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"","code":"barker_proposal(   scale = NULL,   shape = NULL,   sample_auxiliary = stats::rnorm,   sample_uniform = stats::runif )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"scale Scale parameter proposal distribution. non-negative scalar value determining scale steps proposed. shape Shape parameter proposal distribution. Either vector corresponding diagonal shape matrix per-dimension scaling factors, matrix allowing arbitrary linear transformations. sample_auxiliary Function generates random vector auxiliary variable distribution. sample_uniform Function generates random vector standard uniform distribution given integer size.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"details see vignette: vignette(\"barker-proposal\", package = \"rmcmc\")","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"Livingstone, S., & Zanella, G. (2022). Barker proposal: combining robustness efficiency gradient-based MCMC. Journal Royal Statistical Society Series B: Statistical Methodology, 84(2), 496-523.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/barker_proposal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new Barker proposal object. ‚Äî barker_proposal","text":"","code":"target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x ) proposal <- barker_proposal(scale = 1.) state <- chain_state(c(0., 0.)) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) ) log_density_ratio <- proposal$log_density_ratio(   state, proposed_state, target_distribution ) proposal$update(scale = 0.5)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"Convenience function creating Barker proposal bimodal auxiliary noise variable distribution, corresponding equally-weighted normal components shared variance sigma means ¬±sqrt(1 - sigma^2). choice noise distribution suggested Vogrinc et al. (2023) found give improved performance default choice standard normal auxiliary noise distribution range targets.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"","code":"bimodal_barker_proposal(   sigma = 0.1,   scale = NULL,   shape = NULL,   sample_uniform = stats::runif )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"sigma Standard deviation equally-weighted normal components bimodal auxiliary noise distribution, corresponding means ¬±sqrt(1 - sigma^2). scale Scale parameter proposal distribution. non-negative scalar value determining scale steps proposed. shape Shape parameter proposal distribution. Either vector corresponding diagonal shape matrix per-dimension scaling factors, matrix allowing arbitrary linear transformations. sample_uniform Function generates random vector standard uniform distribution given integer size.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"details see vignette: vignette(\"adjusting-noise-distribution\", package = \"rmcmc\")","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"Vogrinc, J., Livingstone, S., & Zanella, G. (2023). Optimal design Barker proposal locally balanced Metropolis‚ÄìHastings algorithms. Biometrika, 110(3), 579-595.","code":""},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/bimodal_barker_proposal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new Barker proposal object with bimodal noise distribution. ‚Äî bimodal_barker_proposal","text":"","code":"target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x ) proposal <- bimodal_barker_proposal(scale = 1.) state <- chain_state(c(0., 0.)) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) ) log_density_ratio <- proposal$log_density_ratio(   state, proposed_state, target_distribution ) proposal$update(scale = 0.5)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/chain_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a new chain state. ‚Äî chain_state","title":"Construct a new chain state. ‚Äî chain_state","text":"chain state object provides cached access target distribution log density gradient.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/chain_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a new chain state. ‚Äî chain_state","text":"","code":"chain_state(position, momentum = NULL)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/chain_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a new chain state. ‚Äî chain_state","text":"position Position component chain state. momentum Momentum component chain state. Optional.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/chain_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a new chain state. ‚Äî chain_state","text":"New chain state object. list entries position: zero-argument function evaluate position vector. momentum: zero-argument function evaluate momentum vector. dimension: zero-argument function evaluate dimension position momentum vectors. update: function accepting arguments position momentum updating value one state components. copy: function creating copy state object including cached values. log_density: function accepting argument target_distribution evaluating log density target distribution current state, caching value avoid recomputation subsequent calls. gradient_log_density: function accepting argument target_distribution evaluating gradient log density target distribution current state, caching value avoid recomputation subsequent calls.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/chain_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a new chain state. ‚Äî chain_state","text":"","code":"state <- chain_state(c(0.1, -0.5)) target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x ) state$gradient_log_density(target_distribution) #> [1] -0.1  0.5"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"Corresponds Algorithm 2 Andrieu Thoms (2009), restatement method proposed Haario et al. (2001).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"","code":"covariance_shape_adapter(kappa = 1)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"kappa Decay rate exponent [0.5, 1] adaptation learning rate. Value 1 (default) corresponds computing empirical covariance matrix.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"Requires ramcmc package installed access efficient rank-1 Cholesky update function ramcmc::chol_update.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"Andrieu, C., & Thoms, J. (2008). tutorial adaptive MCMC. Statistics Computing, 18, 343-373. Haario, H., Saksman, E., & Tamminen, J. (2001). adaptive Metropolis algorithm. Bernoulli, 7(2): 223-242.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/covariance_shape_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal with shape based on estimate of target distribution covariance matrix. ‚Äî covariance_shape_adapter","text":"","code":"proposal <- barker_proposal() adapter <- covariance_shape_adapter() adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"Create object adapt proposal scale coerce average acceptance rate using dual averaging scheme Nesterov (2009) Hoffman Gelman (2014).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"","code":"dual_averaging_scale_adapter(   initial_scale = NULL,   target_accept_prob = NULL,   kappa = 0.75,   gamma = 0.05,   iteration_offset = 10,   mu = NULL )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"initial_scale Initial value use scale parameter. set explicitly proposal dimension dependent default used. target_accept_prob Target value average accept probability chain. set proposal dependent default used. kappa Decay rate exponent [0.5, 1] adaptation learning rate. Defaults value recommended Hoffman Gelman (2014). gamma Regularization coefficient (log) scale dual averaging algorithm. Controls amount regularization (log) scale towards mu. set non-negative value. Defaults value recommended Hoffman Gelman (2014). iteration_offset Offset chain iteration used iteration based weighting adaptation statistic error estimate. set non-negative value. value greater zero effect stabilizing early iterations. Defaults value recommended Hoffman Gelman (2014). mu Value regularize (log) scale towards. NULL (default), mu set log(10 * initial_scale), recommended Hoffman Gelman (2014).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"Nesterov, Y. (2009). Primal-dual subgradient methods convex problems. Mathematical Programming, 120(1), 221-259. Hoffman, M. D., & Gelman, . (2014). -U-Turn sampler: adaptively setting path lengths Hamiltonian Monte Carlo. Journal Machine Learning Research, 15(1), 1593-1623.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/dual_averaging_scale_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal scale to coerce average acceptance rate using dual averaging scheme of Nesterov (2009) and Hoffman and Gelman (2014). ‚Äî dual_averaging_scale_adapter","text":"","code":"proposal <- barker_proposal() adapter <- dual_averaging_scale_adapter(   initial_scale = 1., target_accept_prob = 0.4 ) adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/example_gaussian_stan_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","title":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","text":"Requires BridgeStan package installed. Generative model assumed form y ~ normal(mu, sigma) unknown mu ~ normal(0, 3) sigma ~ half_normal(0, 3).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/example_gaussian_stan_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","text":"","code":"example_gaussian_stan_model(n_data = 50, seed = 1234L)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/example_gaussian_stan_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","text":"n_data Number independent data points y generate condition model normal(0, 1). seed Integer seed Stan model.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/example_gaussian_stan_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","text":"BridgeStan StanModel object.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/example_gaussian_stan_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an example BridgeStan StanModel object for a Gaussian model. ‚Äî example_gaussian_stan_model","text":"","code":"model <- example_gaussian_stan_model(n_data = 5) #> [1] \"BridgeStan not found at location specified by $BRIDGESTAN environment variable, downloading version 2.6.2 to /home/runner/.bridgestan/bridgestan-2.6.2\" #> [1] \"Done!\" model$param_names() #> [1] \"mu\"    \"sigma\""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"Hamiltonian proposal augments target distribution normally distributed auxiliary momenta variables simulates dynamics Hamiltonian function corresponding negative logarithm density resulting joint target distribution using leapfrog integrator, proposed new state forward integrate state momenta negated ensure reversibility.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"","code":"hamiltonian_proposal(   n_step,   scale = NULL,   shape = NULL,   sample_auxiliary = function(state) stats::rnorm(state$dimension()),   sample_n_step = NULL )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"n_step Number leapfrog steps simulate Hamiltonian dynamics proposed move, parameter passed function specified sample_n_step argument NULL. scale Scale parameter proposal distribution. non-negative scalar value determining scale steps proposed. shape Shape parameter proposal distribution. Either vector corresponding diagonal shape matrix per-dimension scaling factors, matrix allowing arbitrary linear transformations. sample_auxiliary function samples new values auxiliary variables (corresponding linear transform momentum) given current chain state, leaving standard normal target distribution invariant. Defaults function sampling independent standard normal random variates can used implement alternative updates partial momentum refreshment. Function accept single argument passed current chain state. sample_n_step Optionally function randomly samples number leapfrog steps simulate proposed move integer-valued distribution, NULL (default) use fixed deterministic number steps specified n_step argument. function accept single argument passed value n_step can used specify parameter(s) distribution sample number steps .","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"Duane, S., Kennedy, . D., Pendleton, B. J., & Roweth, D. (1987). Hybrid Monte Carlo. Physics Letters B, 195(2), 216-222. Neal, R. M. (2011). MCMC Using Hamiltonian Dynamics. Handbook Markov Chain Monte Carlo (pp. 113-162). Chapman Hall/CRC.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/hamiltonian_proposal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new Hamiltonian proposal object. ‚Äî hamiltonian_proposal","text":"","code":"target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x )  # Proposal with fixed number of leapfrog steps proposal <- hamiltonian_proposal(scale = 1., n_step = 5) state <- chain_state(c(0., 0.)) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) ) log_density_ratio <- proposal$log_density_ratio(   state, proposed_state, target_distribution ) proposal$update(scale = 0.5)  # Proposal with number of steps randomly sampled uniformly from 5:10 sample_uniform_int <- function(lower, upper) {   lower + sample.int(upper - lower + 1, 1) - 1 } proposal <- hamiltonian_proposal(   scale = 1.,   n_step = c(5, 10),   sample_n_step = function(n_step) sample_uniform_int(n_step[1], n_step[2]) ) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) )  # Proposal with partial momentum refreshment partial_momentum_update <- function(state, phi = pi / 4) {   momentum <- state$momentum()   if (is.null(momentum)) {     stats::rnorm(state$dimension())   } else {     cos(phi) * momentum + sin(phi) * stats::rnorm(length(momentum))   } } proposal <- hamiltonian_proposal(   scale = 1.,   n_step = 1,   sample_auxiliary = partial_momentum_update ) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_hamiltonian.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply involution underlying Hamiltonian proposal to a chain state. ‚Äî involution_hamiltonian","title":"Apply involution underlying Hamiltonian proposal to a chain state. ‚Äî involution_hamiltonian","text":"Apply involution underlying Hamiltonian proposal chain state.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_hamiltonian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply involution underlying Hamiltonian proposal to a chain state. ‚Äî involution_hamiltonian","text":"","code":"involution_hamiltonian(state, n_step, scale_and_shape, target_distribution)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_hamiltonian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply involution underlying Hamiltonian proposal to a chain state. ‚Äî involution_hamiltonian","text":"Chain state involution applied.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_langevin.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply involution underlying Langevin proposal to a chain state. ‚Äî involution_langevin","title":"Apply involution underlying Langevin proposal to a chain state. ‚Äî involution_langevin","text":"Apply involution underlying Langevin proposal chain state.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_langevin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply involution underlying Langevin proposal to a chain state. ‚Äî involution_langevin","text":"","code":"involution_langevin(state, scale_and_shape, target_distribution)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/involution_langevin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply involution underlying Langevin proposal to a chain state. ‚Äî involution_langevin","text":"Chain state involution applied.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new Langevin proposal object. ‚Äî langevin_proposal","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"Langevin proposal gradient-based proposal corresponding Euler-Maruyama time discretisation Langevin diffusion.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"","code":"langevin_proposal(scale = NULL, shape = NULL, sample_auxiliary = stats::rnorm)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"scale Scale parameter proposal distribution. non-negative scalar value determining scale steps proposed. shape Shape parameter proposal distribution. Either vector corresponding diagonal shape matrix per-dimension scaling factors, matrix allowing arbitrary linear transformations. sample_auxiliary Function generates random vector auxiliary variable distribution.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"Besag, J. (1994). \"Comments \"Representations knowledge complex systems\" U. Grenander MI Miller\". Journal Royal Statistical Society, Series B. 56: 591‚Äì592. Roberts, G. O., & Tweedie, R. L. (1996). Exponential convergence Langevin distributions discrete approximations. Bernoulli 2 (4), 341 - 363.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/langevin_proposal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new Langevin proposal object. ‚Äî langevin_proposal","text":"","code":"target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x ) proposal <- langevin_proposal(scale = 1.) state <- chain_state(c(0., 0.)) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) ) log_density_ratio <- proposal$log_density_ratio(   state, proposed_state, target_distribution ) proposal$update(scale = 0.5)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_barker.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute logarithm of Barker proposal density ratio. ‚Äî log_density_ratio_barker","title":"Compute logarithm of Barker proposal density ratio. ‚Äî log_density_ratio_barker","text":"Compute logarithm Barker proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_barker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute logarithm of Barker proposal density ratio. ‚Äî log_density_ratio_barker","text":"","code":"log_density_ratio_barker(   state,   proposed_state,   target_distribution,   scale_and_shape )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_barker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute logarithm of Barker proposal density ratio. ‚Äî log_density_ratio_barker","text":"state Current chain state. proposed_state Proposed chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. scale_and_shape Scalar, vector matrix scales shapes proposal distribution. scalar (case value non-negative) auxiliary vector isotropically scaled value. vector (case value equal length dimension space entries non-negative) dimension auxiliary vector scaled separately. matrix (case value square matrix size equal dimension space) pre-multiplying auxiliary vector arbitrary linear transformations can performed.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_barker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute logarithm of Barker proposal density ratio. ‚Äî log_density_ratio_barker","text":"Logarithm proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_hamiltonian.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute logarithm of Hamiltonian proposal density ratio. ‚Äî log_density_ratio_hamiltonian","title":"Compute logarithm of Hamiltonian proposal density ratio. ‚Äî log_density_ratio_hamiltonian","text":"Compute logarithm Hamiltonian proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_hamiltonian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute logarithm of Hamiltonian proposal density ratio. ‚Äî log_density_ratio_hamiltonian","text":"","code":"log_density_ratio_hamiltonian(   state,   proposed_state,   target_distribution,   scale_and_shape )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_hamiltonian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute logarithm of Hamiltonian proposal density ratio. ‚Äî log_density_ratio_hamiltonian","text":"state Current chain state. proposed_state Proposed chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. scale_and_shape Scalar, vector matrix scales shapes proposal distribution. scalar (case value non-negative) auxiliary vector isotropically scaled value. vector (case value equal length dimension space entries non-negative) dimension auxiliary vector scaled separately. matrix (case value square matrix size equal dimension space) pre-multiplying auxiliary vector arbitrary linear transformations can performed.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_hamiltonian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute logarithm of Hamiltonian proposal density ratio. ‚Äî log_density_ratio_hamiltonian","text":"Logarithm proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_langevin.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute logarithm of Langevin proposal density ratio. ‚Äî log_density_ratio_langevin","title":"Compute logarithm of Langevin proposal density ratio. ‚Äî log_density_ratio_langevin","text":"Compute logarithm Langevin proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_langevin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute logarithm of Langevin proposal density ratio. ‚Äî log_density_ratio_langevin","text":"","code":"log_density_ratio_langevin(   state,   proposed_state,   target_distribution,   scale_and_shape )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_langevin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute logarithm of Langevin proposal density ratio. ‚Äî log_density_ratio_langevin","text":"state Current chain state. proposed_state Proposed chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. scale_and_shape Scalar, vector matrix scales shapes proposal distribution. scalar (case value non-negative) auxiliary vector isotropically scaled value. vector (case value equal length dimension space entries non-negative) dimension auxiliary vector scaled separately. matrix (case value square matrix size equal dimension space) pre-multiplying auxiliary vector arbitrary linear transformations can performed.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_langevin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute logarithm of Langevin proposal density ratio. ‚Äî log_density_ratio_langevin","text":"Logarithm proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_random_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute logarithm of random_walk proposal density ratio. ‚Äî log_density_ratio_random_walk","title":"Compute logarithm of random_walk proposal density ratio. ‚Äî log_density_ratio_random_walk","text":"Compute logarithm random_walk proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_random_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute logarithm of random_walk proposal density ratio. ‚Äî log_density_ratio_random_walk","text":"","code":"log_density_ratio_random_walk(   state,   proposed_state,   target_distribution,   scale_and_shape )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_random_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute logarithm of random_walk proposal density ratio. ‚Äî log_density_ratio_random_walk","text":"state Current chain state. proposed_state Proposed chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. scale_and_shape Scalar, vector matrix scales shapes proposal distribution. scalar (case value non-negative) auxiliary vector isotropically scaled value. vector (case value equal length dimension space entries non-negative) dimension auxiliary vector scaled separately. matrix (case value square matrix size equal dimension space) pre-multiplying auxiliary vector arbitrary linear transformations can performed.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/log_density_ratio_random_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute logarithm of random_walk proposal density ratio. ‚Äî log_density_ratio_random_walk","text":"Logarithm proposal density ratio.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/random_walk_proposal.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","title":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","text":"Gaussian random walk proposal samples new proposed state perturbing current state zero-mean normally distributed noise.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/random_walk_proposal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","text":"","code":"random_walk_proposal(   scale = NULL,   shape = NULL,   sample_auxiliary = stats::rnorm )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/random_walk_proposal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","text":"scale Scale parameter proposal distribution. non-negative scalar value determining scale steps proposed. shape Shape parameter proposal distribution. Either vector corresponding diagonal shape matrix per-dimension scaling factors, matrix allowing arbitrary linear transformations. sample_auxiliary Function generates random vector auxiliary variable distribution.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/random_walk_proposal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/random_walk_proposal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new (Gaussian) random walk proposal object. ‚Äî random_walk_proposal","text":"","code":"target_distribution <- list(log_density = function(x) -sum(x^2) / 2) proposal <- random_walk_proposal(scale = 1.) state <- chain_state(c(0., 0.)) withr::with_seed(   876287L, proposed_state <- proposal$sample(state, target_distribution) ) log_density_ratio <- proposal$log_density_ratio(   state, proposed_state, target_distribution ) proposal$update(scale = 0.5)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"Requires ramcmc package installed.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"","code":"robust_shape_adapter(   initial_scale = NULL,   target_accept_prob = NULL,   kappa = 0.6 )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"initial_scale Initial value use scale parameter. set explicitly proposal dimension dependent default used. target_accept_prob Target value average accept probability chain. set proposal dependent default used. kappa Decay rate exponent [0.5, 1] adaptation learning rate.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"Vihola, M. (2012). Robust adaptive Metropolis algorithm coerced acceptance rate. Statistics Computing, 22, 997-1008. doi:10.1007/s11222-011-9269-5","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/robust_shape_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal shape (and scale) using robust adaptive Metropolis algorithm of Vihola (2012). ‚Äî robust_shape_adapter","text":"","code":"proposal <- barker_proposal() adapter <- robust_shape_adapter(initial_scale = 1., target_accept_prob = 0.4) adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_barker.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample new state from Barker proposal. ‚Äî sample_barker","title":"Sample new state from Barker proposal. ‚Äî sample_barker","text":"Sample new state Barker proposal.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_barker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample new state from Barker proposal. ‚Äî sample_barker","text":"","code":"sample_barker(   state,   target_distribution,   scale_and_shape,   sample_auxiliary = stats::rnorm,   sample_uniform = stats::runif )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_barker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample new state from Barker proposal. ‚Äî sample_barker","text":"state Current chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. scale_and_shape Scalar, vector matrix scales shapes proposal distribution. scalar (case value non-negative) auxiliary vector isotropically scaled value. vector (case value equal length dimension space entries non-negative) dimension auxiliary vector scaled separately. matrix (case value square matrix size equal dimension space) pre-multiplying auxiliary vector arbitrary linear transformations can performed. sample_auxiliary Function generates random vector auxiliary variable distribution. sample_uniform Function generates random vector standard uniform distribution given integer size.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_barker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample new state from Barker proposal. ‚Äî sample_barker","text":"Proposed new chain state.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_chain.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a Markov chain ‚Äî sample_chain","title":"Sample a Markov chain ‚Äî sample_chain","text":"Sample Markov chain using Metropolis-Hastings kernel user-specified target distribution proposal (defaulting Barker proposal), optionally adapting proposal parameters warm-stage.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_chain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a Markov chain ‚Äî sample_chain","text":"","code":"sample_chain(   target_distribution,   initial_state,   n_warm_up_iteration,   n_main_iteration,   proposal = barker_proposal(),   adapters = list(scale_adapter(), shape_adapter()),   show_progress_bar = TRUE,   trace_warm_up = FALSE )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_chain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a Markov chain ‚Äî sample_chain","text":"target_distribution Target stationary distribution chain. One : one-sided formula specifying expression log density target distribution passed target_distribution_from_log_density_formula() construct functions evaluate log density gradient using deriv(). bridgestan::StanModel instance (requires bridgestan installed) specifying target model data. passed target_distribution_from_stan_model() using default values optional arguments - override call target_distribution_from_stan_model() directly pass returned list target_distribution argument . list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient (required gradient-based proposals). alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. list may also contain named entry trace_function, correspond function given current chain state outputs named vector list variables trace main (non-adaptive) chain iteration. trace_function entry specified, default behaviour trace position component chain state along log density target distribution. initial_state Initial chain state. Either vector specifying just position component chain state list output chain_state specifying full chain state. n_warm_up_iteration Number warm-(adaptive) chain iterations run. n_main_iteration Number main (non-adaptive) chain iterations run. proposal Proposal distribution object. Defaults Barker proposal, output barker_proposal(). Proposal objects lists must minimally define entries sample, function generate sample proposal distribution given current chain state log_density_ratio, function compute log density ratio proposal given pair current proposed chain states. adapters used adaptively tune proposal scale shape parameters, default behaviour sample_chain, additionally list must also define entries: update function updating parameters proposal, parameters function getting current proposal parameter values, default_target_accept_prob function getting proposal specific default target acceptance probability scale adaptation default_initial_scale function getting proposal dimension dependent default initial value scale parameter. adapters List adapters tune proposal parameters warm-. Defaults using list instances scale_adapter() shape_adapter(), corresponding respectively, adapting scale coerce average acceptance rate target value using dual-averaging algorithm, adapting shape estimate covariance target distribution. show_progress_bar Whether show progress bars sampling. Requires progress package installed effect. trace_warm_up Whether record chain traces adaptation / transition statistics (adaptive) warm-iterations addition (non-adaptive) main chain iterations.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_chain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a Markov chain ‚Äî sample_chain","text":"list entries final_state: final chain state, traces: matrix named columns contained traced variables main chain iteration, variables along columns iterations along rows. statistics: matrix named columns containing transition statistics main chain iteration, statistics along columns iterations along rows. warm_up_traces: matrix named columns contained traced variables warm-chain iteration, variables along columns iterations along rows. present trace_warm_up = TRUE. warm_up_statistics: matrix named columns containing adaptation transition statistics warm-chain iteration, statistics along columns iterations along rows. present trace_warm_up = TRUE.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_chain.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a Markov chain ‚Äî sample_chain","text":"","code":"target_distribution <- list(   log_density = function(x) -sum(x^2) / 2,   gradient_log_density = function(x) -x ) withr::with_seed(876287L, {   results <- sample_chain(     target_distribution,     initial_state = stats::rnorm(2),     n_warm_up_iteration = 1000,     n_main_iteration = 1000   ) })"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_hamiltonian.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample new state from Hamiltonian proposal. ‚Äî sample_hamiltonian","title":"Sample new state from Hamiltonian proposal. ‚Äî sample_hamiltonian","text":"Sample new state Hamiltonian proposal.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_hamiltonian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample new state from Hamiltonian proposal. ‚Äî sample_hamiltonian","text":"","code":"sample_hamiltonian(   state,   target_distribution,   n_step,   scale_and_shape,   sample_auxiliary,   sample_n_step )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_langevin.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample new state from Langevin proposal. ‚Äî sample_langevin","title":"Sample new state from Langevin proposal. ‚Äî sample_langevin","text":"Sample new state Langevin proposal.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_langevin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample new state from Langevin proposal. ‚Äî sample_langevin","text":"","code":"sample_langevin(   state,   target_distribution,   scale_and_shape,   sample_auxiliary = stats::rnorm )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_langevin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample new state from Langevin proposal. ‚Äî sample_langevin","text":"sample_auxiliary Function generates random vector auxiliary variable distribution.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_langevin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample new state from Langevin proposal. ‚Äî sample_langevin","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_metropolis_hastings.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from Metropolis-Hastings kernel. ‚Äî sample_metropolis_hastings","title":"Sample from Metropolis-Hastings kernel. ‚Äî sample_metropolis_hastings","text":"Sample Metropolis-Hastings kernel.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_metropolis_hastings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from Metropolis-Hastings kernel. ‚Äî sample_metropolis_hastings","text":"","code":"sample_metropolis_hastings(   state,   target_distribution,   proposal,   sample_uniform = stats::runif )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_metropolis_hastings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from Metropolis-Hastings kernel. ‚Äî sample_metropolis_hastings","text":"state Current chain state. target_distribution Target stationary distribution chain. list named entries log_density gradient_log_density corresponding respectively functions evaluating logarithm (potentially unnormalized) density target distribution gradient. alternative gradient_log_density entry value_and_gradient_log_density may instead provided function returning value gradient logarithm (unnormalized) density target distribution list names value gradient respectively. proposal Proposal distribution object. Must define entries sample, function generate sample proposal distribution given current chain state log_density_ratio, function compute log density ratio proposal given pair current proposed chain states. sample_uniform Function generates random vector standard uniform distribution given integer size.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_metropolis_hastings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from Metropolis-Hastings kernel. ‚Äî sample_metropolis_hastings","text":"List named entries state: corresponding new chain state, proposed_state: corresponding proposed chain state, statistics: list named entries statistics transition, consisting named entry accept_prob Metropolis acceptance probability.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_random_walk.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample new state from random walk proposal. ‚Äî sample_random_walk","title":"Sample new state from random walk proposal. ‚Äî sample_random_walk","text":"Sample new state random walk proposal.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_random_walk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample new state from random walk proposal. ‚Äî sample_random_walk","text":"","code":"sample_random_walk(   state,   target_distribution,   scale_and_shape,   sample_auxiliary = stats::rnorm )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_random_walk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample new state from random walk proposal. ‚Äî sample_random_walk","text":"sample_auxiliary Function generates random vector auxiliary variable distribution.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/sample_random_walk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample new state from random walk proposal. ‚Äî sample_random_walk","text":"Proposal object. list entries sample: function generate sample proposal distribution given current chain state, log_density_ratio:  function compute log density ratio proposal given pair current proposed chain states, update: function update parameters proposal, parameters: function return list current parameter values. default_target_accept_prob: function returning default target acceptance rate use scale adaptation. default_initial_scale: function given dimension gives default value use initial proposal scale parameter.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"Create object adapt proposal scale coerce average acceptance rate.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"","code":"scale_adapter(   algorithm = \"dual_averaging\",   initial_scale = NULL,   target_accept_prob = NULL,   ... )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"algorithm String specifying algorithm use. One : \"stochastic_approximation\" use Robbins-Monro (1951) based scheme, \"dual_averaging\" use dual-averaging scheme Nesterov (2009). initial_scale Initial value use scale parameter. set explicitly proposal dimension dependent default used. target_accept_prob Target value average accept probability chain. set proposal dependent default used. ... additional algorithmic parameters pass dual_averaging_scale_adapter() stochastic_approximation_scale_adapter().","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"Nesterov, Y. (2009). Primal-dual subgradient methods convex problems. Mathematical Programming, 120(1), 221-259. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 400-407.","code":""},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/scale_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal scale to coerce average acceptance rate. ‚Äî scale_adapter","text":"","code":"proposal <- barker_proposal() adapter <- scale_adapter(initial_scale = 1., target_accept_prob = 0.4) adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/shape_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal shape. ‚Äî shape_adapter","title":"Create object to adapt proposal shape. ‚Äî shape_adapter","text":"Create object adapt proposal shape.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/shape_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal shape. ‚Äî shape_adapter","text":"","code":"shape_adapter(type = \"covariance\", kappa = 1)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/shape_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal shape. ‚Äî shape_adapter","text":"type Type shape adapter use. One : \"variance\": Diagonal shape matrix adaptation based estimates target distribution variances (see variance_shape_adapter()), \"covariance\": Dense shape matrix adaptation based estimates target distribution covariance matrix (see covariance_shape_adapter()). kappa Decay rate exponent [0.5, 1] adaptation learning rate. Value 1 (default) corresponds computing empirical (co)variances.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/shape_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal shape. ‚Äî shape_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/shape_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal shape. ‚Äî shape_adapter","text":"","code":"proposal <- barker_proposal() adapter <- shape_adapter() adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"combined covariance_shape_adapter() corresponds Algorithm 4 Andrieu Thoms (2009).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"","code":"stochastic_approximation_scale_adapter(   initial_scale = NULL,   target_accept_prob = NULL,   kappa = 0.6 )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"initial_scale Initial value use scale parameter. set explicitly proposal dimension dependent default used. target_accept_prob Target value average accept probability chain. set proposal dependent default used. kappa Decay rate exponent [0.5, 1] adaptation learning rate.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"Andrieu, C., & Thoms, J. (2008). tutorial adaptive MCMC. Statistics Computing, 18, 343-373. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 400-407.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/stochastic_approximation_scale_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal scale to coerce average acceptance rate using a Robbins and Monro (1951) scheme. ‚Äî stochastic_approximation_scale_adapter","text":"","code":"proposal <- barker_proposal() adapter <- stochastic_approximation_scale_adapter(   initial_scale = 1., target_accept_prob = 0.4 ) adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_log_density_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","title":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","text":"Construct target distribution formula specifying log density.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_log_density_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","text":"","code":"target_distribution_from_log_density_formula(log_density_formula)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_log_density_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","text":"log_density_formula Formula right-hand side specifies expression logarithm (unnormalized) density target distribution.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_log_density_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","text":"list entries log_density: function evaluate log density function target distribution given current position vector. value_and_gradient_log_density: function evaluate value gradient log density function target distribution given current position vector, returning list entries value gradient.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_log_density_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct target distribution from a formula specifying log density. ‚Äî target_distribution_from_log_density_formula","text":"","code":"target_distribution <- target_distribution_from_log_density_formula(   ~ (-(x^2 + y^2) / 8 - (x^2 - y)^2 - (x - 1)^2 / 10) ) target_distribution$value_and_gradient_log_density(c(0.1, -0.3)) #> $value #> [1] -0.1896 #>  #> $gradient #>     x     y  #> 0.031 0.695  #>"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_stan_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","title":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","text":"Construct target distribution BridgeStan StanModel object.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_stan_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","text":"","code":"target_distribution_from_stan_model(   model,   include_log_density = TRUE,   include_generated_quantities = FALSE,   include_transformed_parameters = FALSE )"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_stan_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","text":"model Stan model object use target (posterior) distribution. include_log_density Whether include entry log_density corresponding current log density target distribution values returned trace function. include_generated_quantities Whether included generated quantities Stan model definition values returned trace function. include_transformed_parameters Whether include transformed parameters Stan model definition values returned trace function.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_stan_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","text":"list entries log_density: function evaluate log density function target distribution given current position vector. value_and_gradient_log_density: function evaluate value gradient log density function target distribution given current position vector, returning list entries value gradient. trace_function: function given chain_state() object returns named vector values trace sampling. constrained parameter values model always included.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/target_distribution_from_stan_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct target distribution from a BridgeStan StanModel object. ‚Äî target_distribution_from_stan_model","text":"","code":"model <- example_gaussian_stan_model() target_distribution <- target_distribution_from_stan_model(model) withr::with_seed(   876287L, state <- chain_state(stats::rnorm(model$param_unc_num())) ) state$log_density(target_distribution) #> [1] -18.93961 target_distribution$trace_function(state) #>          mu       sigma log_density  #>  -0.5220125   0.9487576 -18.9396077"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"Corresponds variance variant Algorithm 2 Andrieu Thoms (2009), restatement method proposed Haario et al. (2001).","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"","code":"variance_shape_adapter(kappa = 1)"},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"kappa Decay rate exponent [0.5, 1] adaptation learning rate. Value 1 (default) corresponds computing empirical variances.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"List functions entries initialize, function initializing adapter state proposal parameters beginning chain, update function updating adapter state proposal parameters chain iteration, finalize function performing final updates adapter state proposal parameters completion chain sampling (may NULL unused). state zero-argument function accessing current values adapter state variables.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"Andrieu, C., & Thoms, J. (2008). tutorial adaptive MCMC. Statistics Computing, 18, 343-373. Haario, H., Saksman, E., & Tamminen, J. (2001). adaptive Metropolis algorithm. Bernoulli, 7(2): 223-242.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/reference/variance_shape_adapter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create object to adapt proposal with per dimension scales based on estimates of target distribution variances. ‚Äî variance_shape_adapter","text":"","code":"proposal <- barker_proposal() adapter <- variance_shape_adapter() adapter$initialize(proposal, chain_state(c(0, 0)))"},{"path":[]},{"path":"http://github-pages.ucl.ac.uk/rmcmc/news/index.html","id":"rmcmc-011","dir":"Changelog","previous_headings":"","what":"rmcmc 0.1.1","title":"rmcmc 0.1.1","text":"CRAN release: 2025-02-04 Resubmission CRAN fix minor issues formatting DESCRIPTION restoring graphical parameters function vignette.","code":""},{"path":"http://github-pages.ucl.ac.uk/rmcmc/news/index.html","id":"rmcmc-010","dir":"Changelog","previous_headings":"","what":"rmcmc 0.1.0","title":"rmcmc 0.1.0","text":"Initial CRAN submission.","code":""}]
